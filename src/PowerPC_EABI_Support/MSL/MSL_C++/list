#ifndef _STD_LIST_
#define _STD_LIST

// documented from the Food Network - Cook or Be Cooked! debug build
// (CulinaryAcademy_debug.elf)

#include <MSL_C++/algorithm>
#include <MSL_C++/cstddef>
#include <MSL_C++/memory>
#include <MSL_C++/stdexcept>
#include <MSL_C++/Metrowerks/compressed_pair.h>
#include <MSL_C++/Metrowerks/int2type.h>

namespace std {

template <typename T, typename Allocator>
class __list_deleter {
public:
    struct node;
    struct node_base;

    typedef T* pointer;
    typedef const T* const_pointer;
    typedef T& reference;
    typedef const T& const_reference;
    typedef node_base* node_base_pointer;
    typedef const node_base* const_node_base_pointer;
    typedef node* node_pointer;
    typedef const node* const_node_pointer;

    struct node_base {
        node_pointer prev_;
        node_pointer next_;
    };

    struct node : node_base {
        T data_;
    };

    template <bool B = false>
    class generic_iterator {
    public:
        generic_iterator() { }
        generic_iterator(node_pointer n)
            : node_(n)
        { }

        generic_iterator(node_base_pointer n)
            : node_((node_pointer)n)
        { }

        reference operator*() {
            return node_->data_;
        }

        const_reference operator*() const {
            return node_->data_;
        }

        pointer operator->() {
            return &node_->data_;
        }

        const_pointer operator->() const {
            return &node_->data_;
        }

        generic_iterator operator++(int) {
            generic_iterator temp = *this;
            node_++;
            return temp;
        }

        generic_iterator operator--(int) {
            generic_iterator temp = *this;
            ptr--;
            return temp;
        }

        generic_iterator& operator++() {
            node_++;
            return *this;
        }

        generic_iterator& operator--() {
            node_--;
            return *this;
        }

        friend bool operator==(const generic_iterator& x, const generic_iterator& y) {
            return x.node_ == y.node_;
        }

        friend bool operator!=(const generic_iterator& x, const generic_iterator& y) {
            return x.node_ != y.node_;
        }
    private:
        node* node_;
    };

    inline __list_deleter()
        : size_(0)
        , end_(alloc())
    {
        node_base& t = tail();
        t.next_ = (node_pointer)&t;
        t.prev_ = (node_pointer)&t;
    }

    typedef generic_iterator<false> iterator; // probably
    // then what is const_iterator?

    ~__list_deleter() {
        iterator i;
        erase(i, this, begin(), end());
    }

    iterator end() {
        return iterator(&tail());
    }

    iterator begin() {
        return iterator(tail().next_);
    }

    const Allocator& alloc() const {
        return size_.first();
    }

    node_base& tail() {
        return end_.second();
    }

    const node_base& tail() const {
        return end_.second();
    }

    void clear() {
        iterator i;
        erase(i, this, begin(), end());
    }

    // the erase function from Food Network - Cook or Be Cooked! has this signature
    // iterator erase(iterator first, iterator last);
    // perhaps it changed after?


    static iterator erase(iterator& dst, __list_deleter* list, iterator first, iterator last);
    static iterator erase(iterator& dst, __list_deleter* list, iterator position);
    static iterator insert(iterator& dst, __list_deleter* list, iterator position, const_reference x);
protected:
    Metrowerks::compressed_pair<Allocator, size_t> size_;
    Metrowerks::compressed_pair<allocator<node_base>, node_base> end_;
};


template <typename T, typename Allocator>
class __list_imp : public __list_deleter<T, Allocator> {
    typedef __list_deleter<T, Allocator> Base;
    typedef Base::const_reference const_reference;
public:
    ~__list_imp() { }

    void push_back(const_reference x) {
        iterator i;
        insert(i, this, end(), x);
    }
};

template <typename T, typename Allocator = allocator<T> >
class list : public __list_imp<T, Allocator> {
public:
    ~list() { }
};


}

#endif