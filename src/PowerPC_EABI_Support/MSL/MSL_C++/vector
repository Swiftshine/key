#ifndef _STD_VECTOR
#define _STD_VECTOR

// documented from the Food Network - Cook or Be Cooked! debug build
// (CulinaryAcademy_debug.elf)

#include <MSL_C++/algorithm>
#include <MSL_C++/cstddef>
#include <MSL_C++/memory>
#include <MSL_C++/stdexcept>
#include <MSL_C++/Metrowerks/compressed_pair.h>
#include <MSL_C++/Metrowerks/int2type.h>

namespace std {

template <bool>
class __vector_common {
public:
    static void throw_length_error();
};

template <typename T, class Allocator>
class __vec_deleter {
public:
    typedef typename Metrowerks::compressed_pair<size_t, Allocator>::second_param allocator_param;
    typedef T value_type;
    typedef Allocator allocator_type;
    typedef size_t size_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef T* iterator;
    typedef const T* const_iterator;
    typedef T* pointer;
    typedef const pointer const_pointer;

    __vec_deleter()
        : data_(nullptr)
        , size_(0)
        , capacity_(0)
    { }

    explicit __vec_deleter(allocator_param a)
        : data_(nullptr)
        , size_(0)
        , capacity_(0, a)
    { }

    ~__vec_deleter() DONT_INLINE_CLASS {
        if (data_ != nullptr) {
            clear();
            alloc().deallocate(data_, cap());
        }
    }

    reference operator[](size_t n) {
        return data_[n];
    }

    const_reference operator[](size_t n) const {
        return data_[n];
    }
    
    iterator begin() {
        return data_;
    }

    iterator end() {
        return data_ + size_;
    }

    reference back() {
        return data_[size_ - 1];
    }

    const_reference back() const {
        return data_[size_ - 1];
    }

    void throw_length_error();

    void clear() {
        erase_at_end(size_);
    }

    void erase_at_end(size_t n) {
        erase_at_end(n, Metrowerks::int2type<1>());
    }

    void erase_at_end(size_t n, Metrowerks::int2type<1>) DONT_INLINE_CLASS {
        T* e = end();
        size_ -= n;

        while (n != 0) {
            e--;
            e->~T();
            n--;
        }
    }

    size_t& cap() {
        return capacity_.first();
    }
    
    Allocator alloc() const {
        return capacity_.second();
    }

    inline void push_back(const_reference x) {
        push_back(x, Metrowerks::int2type<1>());
    }

    inline void push_back(const_reference x, Metrowerks::int2type<1>) {
        if (size_ < cap()) {
            size_++;
            back() = x;
        } else {
            sub_push_back(x);
        }
    }

    void sub_push_back(const_reference x) {
        sub_push_back(x, Metrowerks::int2type<1>());
    }

    void sub_push_back(const_reference x, Metrowerks::int2type<1>);

    void allocate(size_t min, size_t max) {
        allocate(min, max, Metrowerks::int2type<1>());
    }

    void allocate(size_t min, size_t max, Metrowerks::int2type<1> t) {
        allocate(max, t);
    }

    void allocate(size_t n, Metrowerks::int2type<1> t) {
        size_t max = max_size();

        if (max < n) {
            __vector_common<true>::throw_length_error();
        }

        data_ = alloc().allocate(n);
        cap() = n;
    }

    void append_realloc(size_t n, const_reference x) {
        __vec_deleter_helper<T, Allocator> tmp(alloc());
        
        size_t max = tmp.grow_by((size_ + n) - cap());
        tmp.allocate(size_ + n, max);
        tmp.start_ = size_;
        tmp.construct_at_end(n, x);
        tmp.move_construct_to_begin(begin(), end());
        optimize_after_moved_from();

        std::swap(cap(), tmp.cap());
        std::swap(data_, tmp.data_);
        std::swap(size_, tmp.size_);
    }

    void optimize_after_moved_from() {
        optimize_after_moved_from(Metrowerks::int2type<1>());
    }

    void optimize_after_moved_from(Metrowerks::int2type<1>) {
        size_ = 0;
    }

    bool expand_by(size_t n) {
        size_t max_cap = 0;
        return expand_by(n, max_cap, Metrowerks::int2type<1>());
    }

    bool expand_by(size_t n, size_t& max_cap, Metrowerks::int2type<1>) {
        max_cap = grow_by(n);
        return false;
    }

    size_t grow_by(size_t n) {
        size_t max = max_size();
        size_t c = cap();

        if (max - c < n) {
            __vector_common<true>::throw_length_error();
        }

        size_t a = max / 3;

        if (c < a) {
            return c + std::max((c + 1) * 3 / 5, n);
        } else if (c < a * 2) {
            return c + std::max((c + 1) / 2, n);
        }

        return max;
    }

    size_t max_size() const {
        return alloc().max_size();
    }

    size_t size() const {
        return size_;
    }

protected:
    T* data_;
    size_t size_;
    Metrowerks::compressed_pair<size_t, Allocator> capacity_;
};

template <typename T, typename Allocator>
void __vec_deleter<T, Allocator>::sub_push_back(const_reference x, Metrowerks::int2type<1>) {
    if (expand_by(1)) {
        size_++;
        back() = x;
    } else {
        append_realloc(1, x);
    }
}

template <typename T, class Allocator>
class __vec_deleter_helper : public __vec_deleter<T, Allocator> {
protected:
    typedef __vec_deleter<T, Allocator> _Base;
    typedef _Base::allocator_param allocator_param;
    typedef _Base::value_type value_type;
    typedef _Base::allocator_type allocator_type;
    typedef _Base::size_type size_type;
    typedef _Base::reference reference;
    typedef _Base::const_reference const_reference;
    typedef _Base::pointer pointer;
    typedef _Base::const_pointer const_pointer;
    typedef _Base::iterator iterator;
    typedef _Base::const_iterator const_iterator;
public:
    __vec_deleter_helper(allocator_param a)
        : __vec_deleter(a)
        , start_(0)
    { }

    ~__vec_deleter_helper() {
        T* start = data_ + start_;
        T* end = start + size_;

        while (start < end) {
            alloc().destroy(end);
            end--;
        }

        size_ = 0;
    }

    void construct_at_end(size_t n, const_reference x) {
        construct_at_end(n, x, Metrowerks::int2type<1>());
    }

    void construct_at_end(size_t n, const_reference x, Metrowerks::int2type<1>) {
        std::fill_n(data_ + start_ + size_, n, x);
        size_ += n;
    }

    void move_construct_to_begin(pointer first, pointer last) {
        move_construct_to_begin(first, last, Metrowerks::int2type<2>());
    }

    void move_construct_to_begin(pointer first, pointer last, Metrowerks::int2type<2>) {
        size_t n = last - first;
        start_ -= n;
        memcpy(data_ + start_, first, n * sizeof(value_type));
        memset(first, 0, n * sizeof(value_type));
        size_ += n;
    }

    size_t start_;
};
template <typename T, class Allocator, bool I>
class __vec_constructor : public __vec_deleter<T, Allocator> {
protected:
    typedef __vec_deleter<T, Allocator> _Base;
    typedef _Base::allocator_param allocator_param;
    typedef _Base::value_type value_type;
    typedef _Base::allocator_type allocator_type;
    typedef _Base::size_type size_type;
    typedef _Base::reference reference;
    typedef _Base::const_reference const_reference;
    typedef _Base::pointer pointer;
    typedef _Base::const_pointer const_pointer;
    typedef _Base::iterator iterator;
    typedef _Base::const_iterator const_iterator;
public:
    __vec_constructor() { }
    ~__vec_constructor();
};

template <typename T, class Allocator>
class __vec_constructor<T, Allocator, true> : public __vec_constructor<T, Allocator, false> {
protected:
    typedef __vec_deleter<T, Allocator> _Deleter;
    typedef __vec_constructor<T, Allocator, false> _Constructor;
    typedef _Constructor::allocator_param allocator_param;
    typedef _Constructor::value_type value_type;
    typedef _Constructor::allocator_type allocator_type;
    typedef _Constructor::size_type size_type;
    typedef _Constructor::reference reference;
    typedef _Constructor::const_reference const_reference;
    typedef _Constructor::pointer pointer;
    typedef _Constructor::const_pointer const_pointer;
    typedef _Constructor::iterator iterator;
    typedef _Constructor::const_iterator const_iterator;

    __vec_constructor() { }
    // ~__vec_constructor() { }

    // inline void push_back(const_reference x) {
    //     _Deleter::push_back((const typename _Deleter::value_type&)(x));
    // }

    reference operator[](size_t n) {
        return _Deleter::operator[](n);
    }

    const_reference operator[](size_t n) const {
        return _Deleter::operator[](n);
    }
};

template <typename T, typename Allocator = allocator<T> >
class vector : public __vec_constructor<T, Allocator, true> {
protected:
    typedef __vec_constructor<T, Allocator, true> _Constructor;
    typedef __vec_deleter<T, Allocator> _Deleter;
    typedef _Constructor::allocator_param allocator_param;
    typedef _Constructor::value_type value_type;
    typedef _Constructor::allocator_type allocator_type;
    typedef _Constructor::size_type size_type;
    typedef _Constructor::reference reference;
    typedef _Constructor::const_reference const_reference;
    typedef _Constructor::pointer pointer;
    typedef _Constructor::const_pointer const_pointer;
    typedef _Constructor::iterator iterator;
    typedef _Constructor::const_iterator const_iterator;
public:
    vector() { }
    // ~vector() { }

    // void push_back(const_reference x) {
    //     _Constructor::push_back(x);
    // }

    void clear() {
        _Deleter::clear();
    }

    reference operator[](size_t n) {
        return _Deleter::operator[](n);
    }

    const_reference operator[](size_t n) const {
        return _Deleter::operator[](n);
    }
};

}
#endif
